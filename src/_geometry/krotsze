from functools import reduce
from pathlib import Path
import time

import dask.array as da
import dask.dataframe as dd
import matplotlib.pyplot as plt
import numpy as np
from opt_einsum import contract
import pyvista as pv
from scipy.spatial import ConvexHull, Delaunay

from collimator import Collimator  # funkcja make_hull
from detector import Detector
from dispersive_element import DispersiveElement  # funkcja make_curved_crystal
from mesh_calculation import CuboidMesh
from port import Port


class Simulation:
    def __init__(
        self,
        element,
        slits_number=10,
        distance_between_points=10,
        crystal_height_step=20,
        crystal_length_step=80,
        savetxt=False,
        plot=True,
    ):
        self.element = element
        self.slits_number = slits_number
        self.distance_between_points = distance_between_points
        self.crystal_height_step = crystal_height_step
        self.crystal_length_step = crystal_length_step
        self.plot = plot

        self._init_cuboid_coordinates()
        self._init_collimator()
        self._init_dispersive_element()
        self._init_port()
        self._init_detector()

        # calculate ray reflection
        (
            self.reflected_points_location,
            self.full_input_array,
        ) = self.calculate_radiation_reflection()
        self.selected_intersections = self.check_ray_transmission()
        self.selected_indices = self.calculate_indices()
        self.plas_points_indices = self.calculate_plasma_points_indices()
        self.distances = self.grab_distances()
        self.angles_of_incident = self.grab_angles()
        self.ddf = self.calculate_radiation_fraction()

        if savetxt:
            self.save_to_file()

    def _init_cuboid_coordinates(self):
        self.cuboid_coordin = self.generate_cuboid_coordinates()

    def _init_collimator(self):
        self.collim = Collimator(self.element, "top closing side", self.slits_number)
        (
            self.collimator_spatial,
            self.slit_coord_crys_side,
            self.slit_coord_plasma_side,
        ) = self.collim.read_colim_coord()

    def _init_dispersive_element(self):
        de = DispersiveElement(
            self.element, self.crystal_height_step, self.crystal_length_step
        )
        self.disp_elem = de.make_curved_crystal()
        self.AOI = de.AOI
        self.max_reflectivity = de.max_reflectivity
        self.radius_central_point = de.radius_central_point
        self.B = de.B
        self.C = de.C

        self.crystal_point_area = self.calculate_crystal_point_area()
        self.crystal_coordinates = da.from_array(self.disp_elem, chunks=(2000, 3))

    def _init_port(self):
        self.port_vertices_coordinates = Port().vertices_coordinates
        self.port_orientation_vector = Port().orientation_vector

    def _init_detector(self):
        self.detector_vertices_coordinates = Detector(self.element).vertices
        self.detector_orientation_vector = Detector(self.element).orientation_vector

    def generate_cuboid_coordinates(self):
        cm = CuboidMesh(self.distance_between_points)
        cuboid_coordinates = cm.outer_cube_mesh
        return da.from_array(cuboid_coordinates, chunks=(2000, 3))

    def calculate_crystal_point_area(self):
        crystal_point_area = round(
            20 * 80 / self.crystal_height_step / self.crystal_length_step, 2
        )
        return crystal_point_area

    @staticmethod
    def line_plane_collision(
        plane_normal, plane_point, ray_direction, ray_point, epsilon=1e-6
    ):
        ndotu = np.tensordot(plane_normal, ray_direction, axes=(0, 2))
        ndotu[np.abs(ndotu) < epsilon] = np.nan
        w = ray_point - plane_point
        x = np.tensordot(plane_normal, w, axes=(0, 2))
        si = -(x / ndotu)[:, :, np.newaxis]
        Psi = w + si * ray_direction + plane_point
        return Psi

    def find_intersection_points_basic(self, p1, p2, p3, plasma, crystal):
        v12 = da.from_array(p2 - p1)
        v13 = da.from_array(p3 - p2)
        plane_normal = np.cross(v12, v13)
        point_on_plane = p1
        ray_directions = plasma - crystal
        intersection_points = self.line_plane_collision(
            plane_normal, point_on_plane, ray_directions, crystal
        )

        return intersection_points

    def check_in_hull_general(
        self, intersection_points, vertices_coordinates, orientation_vector
    ):
        vertices_with_depth = self.make_thick_obj(
            vertices_coordinates, orientation_vector
        )
        hull = Delaunay(vertices_with_depth)

        return hull.find_simplex(intersection_points) >= 0

    #############
    def make_thick_obj(self, vertices_coordinates, orientation_Vector):
        obj_3D_vertices = np.concatenate(
            (
                vertices_coordinates[:4] + orientation_Vector,
                vertices_coordinates[:4] - orientation_Vector,
            )
        ).reshape(8, 3)
        return obj_3D_vertices

    def check_in_hull(
        self, intersection_points: da.array, hull_vertices: np.ndarray
    ) -> da.array:
        tested_in_hull = da.map_blocks(
            self.collim.check_in_hull,
            intersection_points,
            hull_vertices,
            dtype=bool,
            drop_axis=2,
        )
        return tested_in_hull

    def check_in_hull_port(self, intersection_points, hull_points):
        tested_in_hull = da.map_blocks(
            self.check_in_hull_general,
            intersection_points,
            hull_points,
            self.port_orientation_vector,
            dtype=bool,
            drop_axis=2,
        )

        return tested_in_hull

    def calculate_radiation_reflection(self):
        def closest_point_on_line(a, b, p):
            ap = p - a
            ab = b - a
            result = a + da.dot(ap, ab) / da.dot(ab, ab) * ab
            return result

        plasma_coordinates = self.cuboid_coordin.reshape(-1, 1, 3)
        crystal_coordinates = self.crystal_coordinates.reshape(1, -1, 3)

        ### calculate reflection angle
        crystal_vector = self.B - self.C
        crys_axis1 = self.radius_central_point
        crys_axis2 = self.radius_central_point + crystal_vector

        on_axis_crystal_normal_points = da.array([])
        for i in crystal_coordinates[0]:
            xxx = closest_point_on_line(crys_axis1, crys_axis2, i)
            on_axis_crystal_normal_points = np.append(
                on_axis_crystal_normal_points, xxx
            )
        on_axis_crystal_normal_points = on_axis_crystal_normal_points.reshape(1, -1, 3)

        d = -plasma_coordinates + crystal_coordinates
        n = (
            crystal_coordinates - on_axis_crystal_normal_points
        )  # - punkty_na_osi krzywizny krysztalu
        n /= da.linalg.norm(n, axis=2, keepdims=True)
        r = d - 2 * (d * n).sum(axis=-1, keepdims=True) * n
        reflected_points_location = r + crystal_coordinates
        full_input_array = da.stack(
            (
                crystal_coordinates - d,  # plasma
                d + plasma_coordinates,  # crystal
                reflected_points_location,
            ),
            axis=0,
        ).rechunk("auto")

        return reflected_points_location, full_input_array

    def check_ray_transmission(self):
        tests_crys_side = []
        found_intersection_points_crys_side = []

        tests_plasma_side = []
        found_intersection_points_plasma_side = []

        tests_port = []
        found_intersection_points_port = []

        tests_detector = []
        found_intersection_points_detector = []

        for i in range(self.slits_number):
            p1, p2, p3 = self.slit_coord_crys_side[i, :3]
            all_intersection_points_crys_side = self.find_intersection_points_basic(
                p1, p2, p3, self.full_input_array[0], self.full_input_array[1]
            )

            p4, p5, p6 = self.slit_coord_plasma_side[i, :3]
            all_intersection_points_plasma_side = self.find_intersection_points_basic(
                p4, p5, p6, self.full_input_array[0], self.full_input_array[1]
            )

            ### check the collision with collimator's crystal side;
            found_intersection_points_crys_side.append(
                all_intersection_points_crys_side
            )
            tested_in_hull = self.check_in_hull(
                all_intersection_points_crys_side, self.slit_coord_crys_side[i]
            )
            tests_crys_side.append(tested_in_hull)

            ### check the collision with collimator's plasma side ;
            found_intersection_points_plasma_side.append(
                all_intersection_points_plasma_side
            )
            tested_in_hull = self.check_in_hull(
                all_intersection_points_plasma_side, self.slit_coord_plasma_side[i]
            )
            tests_plasma_side.append(tested_in_hull)

        ### check the collision with port
        p7, p8, p9 = self.port_vertices_coordinates[:3]
        all_intersection_points_port = self.find_intersection_points_basic(
            p7, p8, p9, self.full_input_array[0], self.full_input_array[1]
        )
        found_intersection_points_port.append(all_intersection_points_port)
        tested_in_hull = self.check_in_hull_port(
            all_intersection_points_port, self.port_vertices_coordinates[:4]
        )

        # tested_in_hull = self.check_in_hull(all_intersection_points_port, (self.port_vertices_coordinates[:4]))
        tests_port.append(tested_in_hull)

        ### chech the collision with detectors surface
        p10, p11, p12 = self.detector_vertices_coordinates[:3]
        all_intersetion_points_detector = self.find_intersection_points_basic(
            p10, p11, p12, self.full_input_array[2], self.full_input_array[1]
        )

        found_intersection_points_detector.append(all_intersetion_points_detector)
        tested_in_hull = self.check_in_hull_general(
            all_intersetion_points_detector,
            self.detector_vertices_coordinates[:4],
            self.detector_orientation_vector,
        )
        tests_detector.append(tested_in_hull)

        selected_intersections = da.stack(
            (da.array(tests_crys_side), da.array(tests_plasma_side)), axis=0
        )
        selected_intersections = selected_intersections.all(axis=0)
        selected_intersections = selected_intersections.any(axis=0)
        krysztal_pkt = self.crystal_height_step * self.crystal_length_step
        selected_intersections = selected_intersections.reshape(
            -1, len(self.cuboid_coordin), krysztal_pkt
        )

        selected_intersections = da.concatenate(
            (selected_intersections, da.array(tests_detector), da.array(tests_port)),
            axis=0,
        ).rechunk("auto")
        selected_intersections = selected_intersections.all(axis=0)

        print("\n--- Ray transmission calculation finished ---")

        return selected_intersections

    def percentage_transmission(self):
        all_plas_crys_combinations = len(self.cuboid_coordin) * len(
            self.crystal_coordinates
        )
        indices = da.arange(all_plas_crys_combinations).reshape(
            len(self.cuboid_coordin), len(self.crystal_coordinates)
        )
        selected_indices = indices[self.selected_intersections]
        transmission = round(
            len(selected_indices.compute())
            / (len(self.cuboid_coordin) * len(self.crystal_coordinates))
            * 100,  ### TODO zahardkodowane wartosci;
            2,
        )
        print(f"\nTrnasmission is: {transmission}%\n")

    def calculate_indices(self):
        plas_points, crys_points = self.selected_intersections.shape
        all_indices = da.arange(plas_points * crys_points).reshape(
            plas_points, crys_points
        )
        selected_indices = all_indices[self.selected_intersections]
        selected_indices = dd.from_dask_array(selected_indices.compute_chunk_sizes())
        selected_indices = selected_indices.to_frame().reset_index()
        print("\n--- Indices calculated ---")

        return selected_indices

    def calculate_plasma_points_indices(self):
        plas_points_indices = self.selected_indices
        plas_points_indices.columns = ["index", "idx_sel_plas_points"]
        plas_points_indices["idx_sel_plas_points"] = plas_points_indices[
            "idx_sel_plas_points"
        ] // len(self.crystal_coordinates)
        print("\n--- Selected plasma points indices calculated ---")

        return plas_points_indices

    def grab_distances(self, save=False):
        all_data_input = self.full_input_array
        plasma_coordinates = all_data_input[0]
        crystal = all_data_input[1]
        distance_vectors = plasma_coordinates - crystal
        distances = (da.sqrt(da.sum(distance_vectors**2, axis=-1)))[
            self.selected_intersections
        ]
        if save is not False:
            self.selected_indices = (
                self.selected_indices.compute_chunk_sizes().rechunk()
            )
            distances = distances.compute_chunk_sizes().rechunk()

            #### TODO zahardkodowane nazwy do poprawienia
            da.to_zarr(
                self.selected_indices.astype(np.int64),
                "selected_indices.zarr",
                overwrite=True,
            )
            da.to_zarr(distances.astype(np.float32), "distances.zarr", overwrite=True)
        distances = dd.from_dask_array(
            distances.compute_chunk_sizes()
        )  ### WASKIE GARDLO
        distances = distances.to_frame().reset_index()
        print("\n--- Distances calculated ---")

        return distances

    def grab_angles(self, save=False):
        all_data_input = self.full_input_array
        plasma_coordinates = all_data_input[0]
        crystal_coordinates = all_data_input[1]
        reflected_points = all_data_input[2]

        vector_plasma_to_crystal = plasma_coordinates - crystal_coordinates
        reflected_crystal = reflected_points - crystal_coordinates
        cosine_angle_matrix = contract(
            "ijk -> ji", vector_plasma_to_crystal * reflected_crystal
        ).T / (
            da.linalg.norm(vector_plasma_to_crystal, axis=2)
            * da.linalg.norm(reflected_crystal, axis=2)
        )
        angle_radians = da.arccos(cosine_angle_matrix)
        angle_degrees = da.degrees(
            angle_radians
        )  ## angle between ray and normal to the crystal at the incidence point
        angle_of_incident = ((180 - angle_degrees.round(2)) / 2)[
            self.selected_intersections
        ]
        if save is not False:
            self.selected_indices = (
                self.selected_indices.compute_chunk_sizes().rechunk()
            )
            angle_of_incident = angle_of_incident.compute_chunk_sizes().rechunk()

            # TODO zahardkodowane nazwy do poprawienia
            da.to_zarr(
                self.selected_indices.astype(np.int64),
                "selected_indices.zarr",
                overwrite=True,
            )
            da.to_zarr(
                angle_of_incident.astype(np.float32),
                "angle_of_incident.zarr",
                overwrite=True,
            )

        angle_of_incident = dd.from_dask_array(angle_of_incident.compute_chunk_sizes())
        angle_of_incident = angle_of_incident.to_frame().reset_index()
        print("\n--- Angles calculated ---")

        return angle_of_incident

    def calculate_radiation_fraction(self):
        data_frames = [
            self.plas_points_indices,
            self.distances,
            self.angles_of_incident,
        ]
        ddf = reduce(lambda left, right: dd.merge(left, right, on="index"), data_frames)
        ddf = ddf.drop(["index"], axis=1)
        ddf.columns = ["idx_sel_plas_points", "distances", "angle"]

        def calculate_sphere_area(R):
            area_of_a_sphere = 4 * np.pi * R**2
            return area_of_a_sphere

        def calcualte_reflectivity(calculated_angle):
            A1, x1, w1 = (self.max_reflectivity, self.AOI, 2.2)
            profile = A1 * np.exp(-((calculated_angle - x1) ** 2) / (2 * w1**2))

            return profile

        ddf["fraction"] = self.crystal_point_area / calculate_sphere_area(
            ddf["distances"]
        )
        ddf["calc_reflect"] = calcualte_reflectivity(ddf["angle"])
        ddf["total_intensity_fraction"] = ddf["fraction"] * ddf["calc_reflect"]
        ddf = ddf.drop(["distances", "angle", "fraction", "calc_reflect"], axis=1)
        ddf = ddf.groupby("idx_sel_plas_points").sum().reset_index()

        indices = ddf["idx_sel_plas_points"].values
        ddf["plasma_x"] = self.cuboid_coordin[indices][:, 0]
        ddf["plasma_y"] = self.cuboid_coordin[indices][:, 1]
        ddf["plasma_z"] = self.cuboid_coordin[indices][:, 2]
        ddf = ddf[
            [
                "idx_sel_plas_points",
                "plasma_x",
                "plasma_y",
                "plasma_z",
                "total_intensity_fraction",
            ]
        ]
        print(ddf.compute())
        return ddf

    def save_to_file(self):
        """Save dataframe with plasma coordinates and calculated radiation intensity fractions"""
        """TODO - zapis do bazy danych (sql???? czy cos innego?) a nie csv!!!!!!"""
        self.ddf.to_csv(
            Path(__file__).parent.parent.resolve()
            / "_Input_files"
            / "Geometric_data"
            / f"{self.element}"  ####  +top/bottom closing side -resolve
            / f"{self.element}_plasma_coordinates-{self.distance_between_points}_mm_spacing-height_{self.crystal_height_step}-length_{self.crystal_length_step}-slit_{self.slits_number}*.dat",
            sep=";",
            header=True,
            index=False,
        )
        print("\nFile successfully saved!")


elements_list = ["C"]

testing_settings = dict(
    slits_number=10,
    distance_between_points=80,
    crystal_height_step=5,
    crystal_length_step=5,
    savetxt=True,
    plot=False,
)

start = time.time()
if __name__ == "__main__":
    for element in elements_list:
        simul = Simulation(element, **testing_settings)


print(f"\nExecution time is {round((time.time() - start), 2)} s")
